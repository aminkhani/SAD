<h1>Systems Analysis and Design (SAD)
<br>Software Engineering 
</h1>

<h3 id="top">Contents</h3>
<ul>
    <li><a href="#what_is_software">What is Software?</a></li>
    <li><a href="#good_software">Attributes of Good Software</a></li>
    <li><a href="#software_engineering">Software Engineering Definition</a></li>
    <li><a href="#software_ce">Difference between Software Engineering and Computer Science</a></li>
    <li><a href="#software_syseng">Difference between Software Engineering and System Engineering</a></li>
    <li><a href="#challenge">Key Challenges Facing Software Engineering</a></li>
    <li><a href="#costs">Costs of Software Engineering</a></li>
    <li><a href="#technique">Software Engineering Techniques & Methods</a></li>
    <li><a href="#internet">Internet & Software Engineering</a></li>
    <li><a href="#kind_sw">Kinds of Software Product</a>
        <ul>
            <li><a href="#generic">Generic Products</a>
            </li>
            <li><a href="#customized">Customized (or bespoke) software</a></ki>
        </ul>
    </li>
    <li><a href="#important">Importance of Software Engineering</a></li>
    <li><a href="#process">Software Process
        <ul><li><a href="#generic_process">Generic Software Process</a></li></ul>
    </a></li>
</ul>


<h2 id="what_is_software">What is Software?</h2>

- Software is not just the programs themselves but also all associated documentation, libraries, support websites, and configuration data that are needed to make these programs useful.
- Software products may be developed for a particular customer or may be developed for a general market.

<h2 id="good_software">What are the attributes of good software?</h2>

- Good software should deliver the **required functionality and  performance** to the user and should be **maintainable**, **dependable** and **usable**.
- **Acceptability:**
  - Software must be acceptable to the type of users for which it is designed. This means that it must be understandable, usable, and compatible with other systems that they use.
- **Dependability and security:**
  - Software dependability includes a range of characteristics including reliability, security, and safety. Dependable software should not cause physical or economic damage in the event of system failure. Software has to be secure so that malicious users cannot access or damage the system.
- **Efficiency:**
  - Software should not make wasteful use of system resources such as memory and processor cycles. Efficiency therefore includes responsiveness, processing time, resource utilization etc.
- **Maintainability:**
  - Software should be written in such a way that it can evolve to meet the changing needs of customers. This is a critical attribute because software change is an inevitable requirement of a changing business environment.

<h2 id="software_engineering">What is Software Engineering?</h2>

- **The seminal deffinition:**
  - the establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines
- **The IEEE definition:**
  - the application of a **systematic**, **disciplined**, **quantifiable approach** to the **development**, **operation**, and **maintenance** of software; that is, the application of engineering to software.
  
- **Software engineering** is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. In this definition, there are two key phrases:
    1. Engineering discipline. Engineers make things work. They apply theories, methods, and tools where these are appropriate. However, they use them selectively and always try to discover solutions to problems even when there are no applicable theories and methods. Engineers also recognize that they must work within organizational and financial constraints, and they must look for solutions within these constraints.
    2. All aspects of software production. Software engineering is not just concerned with the technical processes of software   development. It also includes activities such as software   project management and the development of tools, methods, and theories to support software development.


<h2 id="software_ce">What is the difference between Software Engineering and Computer Science?</h2>

- Computer Science focuses on theory and fundamentals
- Software Engineering is concerned with the practicalities of developing and delivering useful software.

<h2 id="software_syseng">What is the difference between software engineering and system engineering?</h2>

- System engineering is concerned with all aspects of computer-based systems development including hardware, software and process engineering.
- Software engineering is part of this more general process.

<h2 id="challenge">What are the key challenges facing software engineering?</h2>

- Coping with increasing diversity, demands for reduced delivery times and developing trustworthy software.

<h2 id="costs">What are the costs of software engineering?</h2>

- Roughly 60% of software costs are development costs, 40% are testing costs. For custom software, evolution costs often exceed development costs.

<h2 id="technique">What are the best Software Engineering Techniques & Methods?</h2>

- While all software projects have to be professionally managed and developed, different techniques are appropriate for different types of system. For example, games should always be developed using a series of prototypes whereas safety critical control systems require a complete and analyzable specification to be developed. There are no methods and techniques that are good for everything.

<h2 id="internet">What differences has the Internet made to software engineering?</h2>

- Not only has the Internet led to the development of massive, highly distributed, service-based systems, it has also supported the creation of an “app” industry for mobile devices which has changed the economics of software


<h3 id="kind_sw">There are two kinds of software product:</h3>

1. <span id="generic">**Generic products**.</span> These are stand-alone systems that are produced by a development organization and sold on the open market to any customer who is able to buy them. 
   - Examples of this type of product include apps for mobile devices, software for PCs such as databases, word processors drawing packages, and project management tools. This kind of software also includes “vertical” applications designed for a specific market such as library information systems, accounting systems, or systems for maintaining dental records.


2. <span id="customized">**Customized (or bespoke) software**.</span> These are systems that are commissioned by and developed for a particular customer. A software contractor designs and implements the software especially for that customer. 
   - Examples of this type of software include control systems for electronic devices, systems written to support a particular business process, and air traffic control systems.

<h3 id="important">Software engineering is important for two reasons:</h3>

1.  More and more, individuals and society rely on advanced software systems. We need to be able to produce **reliable and trustworthy systems economically and quickly.**
2.  It is usually **cheaper, in the long run**, to use software engineering methods and techniques for software systems rather than just write programs as a personal programming project. Failure to use software engineering method leads to higher costs for testing, quality assurance, and long-term maintenance. For most types of system, the majority of costs, are the costs of changing the software after it has gone into use.

<h2 id="process">Software Process</h2>

- The systematic approach that is used in software engineering is sometimes called a **software process**. A **software process** is a sequence of activities that leads to the production of a software product. Four fundamental activities are common to all software processes.
  
- A process is a collection of activities, actions and tasks that are performed when some work product is to be created. It is not a rigid prescription for how to build computer software. Rather, it is an adaptable approach that enables the people doing the work to pick and choose the appropriate set of work actions and tasks. 

- Purpose of process is to deliver software in a timely manner and with sufficient quality to satisfy those who have sponsored its creation and those who will use it. 


1. Software specification, where customers and engineers define the software that is to be produced and the constraints on its operation.
2. Software development, where the software is designed and programmed.
3. Software validation, where the software is checked to ensure that it is what the customer requires.
4. Software evolution, where the software is modified to reflect changing customer and market requirements

<h3 id="generic_process">Five Activities of a Generic Process framework:</h3>

1. **Communication:** communicate with customer to understand objectives and gather requirements
2. **Planning:** creates a “map” defines the work by describing the tasks, risks and resources, work products and work schedule. 
3. **Modeling:** Create a “sketch”, what it looks like architecturally, how the constituent parts fit together and other characteristics. 
4. **Construction:** code generation and the testing. 
5. **Deployment:** Delivered to the customer who evaluates the products and provides feedback based on the evaluation. 

- These five framework activities can be used to all software development regardless of the application domain, size of the project, complexity of the efforts etc, though the details will be different in each case. 
- For many software projects, these framework activities are applied iteratively as a project progresses. Each iteration produces a software increment that provides a subset of overall software features and functionality. 

